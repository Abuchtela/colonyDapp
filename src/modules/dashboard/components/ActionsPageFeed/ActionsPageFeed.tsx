import React, { useState, useMemo, ReactElement, ReactNode } from 'react';
import { nanoid } from 'nanoid';
import { FormattedMessage, defineMessages } from 'react-intl';

import { SpinnerLoader } from '~core/Preloaders';

import { getEventsForActions } from '~utils/events';

import {
  useTransactionMessagesQuery,
  AnyUser,
  OneDomain,
  ColonyAction,
  Colony,
  TransactionMessageFragment,
  ParsedEvent,
} from '~data/index';
import { ActionUserRoles, ColonyActions } from '~types/index';
import { ActionsPageFeedType, SystemInfo } from './types';

import ActionsPageFeedItem from './ActionsPageFeedItem';
import ActionsPageEvent from './ActionsPageEvent';
import ActionsPageSystemInfo from './ActionsPageSystemInfo';

import styles from './ActionsPageFeed.css';

const displayName = 'dashboard.ActionsPageFeed';

const MSG = defineMessages({
  loading: {
    id: 'dashboard.ActionsPageFeed.loading',
    defaultMessage: 'Loading action page feed',
  },
});

export interface EventValues {
  actionType: string;
  amount?: string | ReactElement;
  tokenSymbol?: string | ReactElement;
  decimals?: number;
  fromDomain?: OneDomain;
  toDomain?: OneDomain;
  oldVersion?: string;
  newVersion?: string;
  colonyName?: string | ReactElement;
  roles?: ActionUserRoles[];
}

type CustomChildrenRenderFn = (
  eventsFeedItems: Array<ParsedEvent | TransactionMessageFragment | SystemInfo>,
) => ReactNode;

interface Props {
  transactionHash: string;
  networkEvents?: ParsedEvent[];
  systemInfos?: SystemInfo[];
  recipient?: AnyUser;
  values?: EventValues;
  actionType?: string;
  actionData: ColonyAction;
  colony: Colony;
  children?: ReactNode | CustomChildrenRenderFn;
}

const ActionsPageFeed = ({
  transactionHash,
  networkEvents,
  systemInfos,
  values,
  actionType,
  actionData,
  colony,
  children,
}: Props) => {
  const [autogeneratedIds, regenerateIds] = useState<string[]>([]);

  const { data: serverComments, loading, error } = useTransactionMessagesQuery({
    variables: { transactionHash },
  });

  const filteredEvents = useMemo(() => {
    if (networkEvents) {
      return getEventsForActions(networkEvents, actionType as ColonyActions);
    }
    return [];
  }, [actionType, networkEvents]);

  const sortedFeed = useMemo(() => {
    if (filteredEvents && serverComments?.transactionMessages?.messages) {
      const feedItems: Array<
        ParsedEvent | TransactionMessageFragment | SystemInfo
      > = [
        ...filteredEvents,
        ...serverComments.transactionMessages.messages,
      ].sort(
        ({ createdAt: createdAtFirst }, { createdAt: createdAtSecond }) =>
          new Date(createdAtFirst).getTime() -
          new Date(createdAtSecond).getTime(),
      );
      /*
       * If we need to show a system info message in the feed, we take the sorted
       * feed and splice in the required ones based on their manually entered position
       */
      if (systemInfos?.length) {
        systemInfos.map((systemInfoItem) => {
          const { position } = systemInfoItem;
          return feedItems.splice(position, 0, systemInfoItem);
        });
      }
      /*
       * We need to re-generate the ids since the array length now increses
       */
      regenerateIds([...new Array(feedItems.length)].map(nanoid));
      return feedItems;
    }
    return [];
  }, [filteredEvents, systemInfos, serverComments, regenerateIds]);

  if (error) {
    console.error(error);
  }

  if (loading || !serverComments?.transactionMessages) {
    return (
      <div className={styles.loading}>
        <SpinnerLoader />
        <span className={styles.loaderMessage}>
          <FormattedMessage {...MSG.loading} />
        </span>
      </div>
    );
  }

  /*
   * If we have a custom rendering function, or child component, render them
   */
  if (children) {
    return typeof children === 'function' ? children(sortedFeed) : children;
  }

  /*
   * Otherwise fallback to the default rendering setup
   */
  return (
    <ul className={styles.main}>
      {sortedFeed.map((feedItem, index) => {
        /*
         * Event
         */
        if (feedItem.type === ActionsPageFeedType.NetworkEvent) {
          const { name, createdAt, emmitedBy } = feedItem as ParsedEvent;
          return (
            <ActionsPageEvent
              key={autogeneratedIds[index] || index}
              eventIndex={index}
              createdAt={new Date(createdAt)}
              transactionHash={transactionHash}
              eventName={name}
              actionData={actionData}
              values={values}
              emmitedBy={emmitedBy}
              colony={colony}
            />
          );
        }
        /*
         * Comment
         */
        if (feedItem.type === ActionsPageFeedType.ServerComment) {
          const {
            initiator: messageInitiator,
            createdAt,
            sourceId,
            context: { message },
          } = (feedItem as unknown) as TransactionMessageFragment;
          return (
            <ActionsPageFeedItem
              key={sourceId}
              createdAt={createdAt}
              comment={message}
              user={messageInitiator}
            />
          );
        }
        /*
         * System Info
         */
        if (feedItem.type === ActionsPageFeedType.SystemInfo) {
          const { text, textValues, appearance } = feedItem as SystemInfo;
          return (
            <ActionsPageSystemInfo
              key={autogeneratedIds[index] || index}
              tip={text}
              tipValues={textValues}
              appearance={appearance}
            />
          );
        }
        return null;
      })}
    </ul>
  );
};

ActionsPageFeed.displayName = displayName;

export default ActionsPageFeed;
