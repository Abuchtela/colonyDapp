import React, { useState, useMemo } from 'react';
import { useIntl, FormattedMessage, defineMessages } from 'react-intl';
import { nanoid } from 'nanoid';
import findLastIndex from 'lodash/findLastIndex';

import PermissionsLabel from '~core/PermissionsLabel';
import { TransactionMeta, TransactionStatus } from '~dashboard/ActionsPage';
import { ColonyAndExtensionsEvents } from '~types/index';
import { useDataFetcher } from '~utils/hooks';
import ColorTag, { Color } from '~core/ColorTag';
import { ipfsDataFetcher } from '../../../../core/fetchers';

import { EventValues } from '../ActionsPageFeed';
import { STATUS } from '../../ActionsPage/types';
import { EVENT_ROLES_MAP } from '../../ActionsPage/staticMaps';
import {
  ColonyAction,
  useSubgraphColonyMetadataQuery,
  useSubgraphDomainMetadataQuery,
  Colony,
} from '~data/index';
import {
  getSpecificActionValuesCheck,
  sortMetdataHistory,
  parseColonyMetadata,
  parseDomainMetadata,
  getColonyMetadataMessageDescriptorsIds,
  getDomainMetadataMessageDescriptorsIds,
} from '~utils/colonyActions';

import styles from './ActionsPageEvent.css';

const displayName = 'dashboard.ActionsPageFeed.ActionsPageEvent';

const MSG = defineMessages({
  rolesTooltip: {
    id: 'dashboard.ActionsPageFeed.ActionsPageEvent.rolesTooltip',
    defaultMessage: `{icon} {role, select,
      1 {This permission allows modify colony-wide parameters, upgrade the
        colony and manage permissions in Root Domain.}
      6 {This permission allows an account to manipulate payments (tasks) in
        their domain and to raise disputes.}
      other {This is a generic placeholder for a permissions type.
        You should not be seeing this}
    }`,
  },
});

interface Props {
  index: number;
  eventName?: string;
  eventValues?: Record<string, any>;
  transactionHash: string;
  createdAt: Date;
  values?: EventValues;
  emmitedBy?: string;
  actionData: ColonyAction;
  colony: Colony;
}

interface DomainMetadata {
  domainName: string | null;
  domainPurpose: string | null;
  domainColor: string | null;
}

const ActionsPageEvent = ({
  index: eventIndex,
  createdAt,
  transactionHash,
  eventName = ColonyAndExtensionsEvents.Generic,
  values,
  emmitedBy,
  actionData,
  colony: { colonyAddress },
  colony,
}: Props) => {
  let metadataJSON;
  const [metdataIpfsHash, setMetdataIpfsHash] = useState<string | undefined>(
    undefined,
  );
  const [
    previousDomainMetadata,
    setPreviousDomainMetadata,
  ] = useState<DomainMetadata | null>();

  /*
   * @NOTE See nanoId's docs about the reasoning for this
   * https://github.com/ai/nanoid#react
   *
   * We're creating a object with event names for keys, which, as values,
   * have an array of ids, for each available permission
   */
  const [autogeneratedIds] = useState<Record<string, string[]>>(() => {
    const eventsToIdsMap = {};
    Object.keys(EVENT_ROLES_MAP).map((name) => {
      eventsToIdsMap[name] = [...new Array(EVENT_ROLES_MAP[eventName])].map(
        nanoid,
      );
      return null;
    });
    return eventsToIdsMap;
  });

  const colonyMetadataHistory = useSubgraphColonyMetadataQuery({
    variables: {
      address: colonyAddress.toLowerCase(),
    },
  });

  const domainMetadataHistory = useSubgraphDomainMetadataQuery({
    variables: {
      colonyAddress: colonyAddress.toLowerCase(),
      domainId: values?.fromDomain.ethDomainId || 0,
    },
  });
  /*
   * Fetch a historic metadata hash using IPFS
   */
  try {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const { data: ipfsMetadata } = useDataFetcher(
      ipfsDataFetcher,
      [metdataIpfsHash as string],
      [metdataIpfsHash],
    );
    metadataJSON = ipfsMetadata;
  } catch (error) {
    // silent error
  }

  /*
   * Determine if the current medata is different from the previous one,
   * and in what way
   */
  const getColonyMetadataChecks = useMemo(() => {
    if (
      eventName === ColonyAndExtensionsEvents.ColonyMetadata &&
      !!colonyMetadataHistory?.data?.colony &&
      !!actionData
    ) {
      const {
        data: {
          colony: { metadataHistory },
        },
      } = colonyMetadataHistory;
      const sortedMetdataHistory = sortMetdataHistory(metadataHistory);
      const currentMedataIndex = findLastIndex(
        sortedMetdataHistory,
        ({ transaction: { id: hash } }) => hash === actionData.hash,
      );
      /*
       * We have a previous metadata entry
       */
      if (currentMedataIndex > 0) {
        const prevMetdata = sortedMetdataHistory[currentMedataIndex - 1];
        if (prevMetdata) {
          setMetdataIpfsHash(prevMetdata.metadata);
          if (metadataJSON) {
            /*
             * If we have a metadata json, parse into the expected values and then
             * compare them agains the ones from the current action
             *
             * This should be the default case for a colony with metadata history
             */
            return getSpecificActionValuesCheck(
              eventName as ColonyAndExtensionsEvents,
              actionData,
              parseColonyMetadata(metadataJSON),
            );
          }
        }
      }
      /*
       * We don't have a previous metadata entry, so fall back to the current
       * action's values
       */
      const { colonyDisplayName, colonyAvatarHash, colonyTokens } = actionData;
      return {
        nameChanged: !!colonyDisplayName,
        logoChanged: !!colonyAvatarHash,
        tokensChanged: !!colonyTokens.length,
      };
    }
    /*
     * Default fallback, just use the current colony's values
     */
    const {
      displayName: colonyDisplayName,
      avatarHash,
      tokenAddresses,
    } = colony;
    return {
      nameChanged: !!colonyDisplayName,
      logoChanged: !!avatarHash,
      tokensChanged: !!tokenAddresses?.length,
    };
  }, [colonyMetadataHistory, actionData, metadataJSON, eventName, colony]);
  const roleNameMessage = { id: `role.${values?.roles[eventIndex].id}` };
  const { formatMessage } = useIntl();
  const formattedRole = formatMessage(roleNameMessage);

  const getDomainMetadataChecks = useMemo(() => {
    if (
      eventName === ColonyAndExtensionsEvents.DomainMetadata &&
      !!domainMetadataHistory?.data?.domains?.length &&
      !!actionData
    ) {
      const domain = domainMetadataHistory?.data?.domains[0];
      const sortedMetdataHistory = sortMetdataHistory(domain?.metadataHistory);
      const currentMedataIndex = findLastIndex(
        sortedMetdataHistory,
        ({ transaction: { id: hash } }) => hash === actionData.hash,
      );
      /*
       * We have a previous metadata entry
       */
      if (currentMedataIndex > 0) {
        const prevMetdata = sortedMetdataHistory[currentMedataIndex - 1];
        if (prevMetdata) {
          setMetdataIpfsHash(prevMetdata.metadata);
          if (metadataJSON) {
            const previousParsedMetadata = parseDomainMetadata(metadataJSON);
            setPreviousDomainMetadata(previousParsedMetadata);
            return getSpecificActionValuesCheck(
              eventName as ColonyAndExtensionsEvents,
              actionData,
              previousParsedMetadata,
            );
          }
        }
      }
    }
    const { domainColor, domainName, domainPurpose } = actionData;
    return {
      nameChanged: !!domainName,
      colorChanged: !!domainColor,
      descriptionChanged: !!domainPurpose,
    };
  }, [domainMetadataHistory, actionData, metadataJSON, eventName]);

  const getEventTitleMessageDescriptor = useMemo(() => {
    switch (eventName) {
      case ColonyAndExtensionsEvents.ColonyMetadata:
        return getColonyMetadataMessageDescriptorsIds(
          ColonyAndExtensionsEvents.ColonyMetadata,
          getColonyMetadataChecks,
        );
      case ColonyAndExtensionsEvents.DomainMetadata:
        return getDomainMetadataMessageDescriptorsIds(
          ColonyAndExtensionsEvents.DomainMetadata,
          getDomainMetadataChecks,
        );
      default:
        return 'event.title';
    }
  }, [eventName, getDomainMetadataChecks, getColonyMetadataChecks]);
  const { domainPurpose, domainName, domainColor } = actionData;
  return (
    <div className={styles.main}>
      <div className={styles.status}>
        <TransactionStatus status={STATUS.Succeeded} showTooltip={false} />
      </div>
      <div className={styles.content}>
        <div className={styles.text}>
          <FormattedMessage
            id={getEventTitleMessageDescriptor}
            values={{
              ...values,
              fromDomain: values?.fromDomain?.name,
              toDomain: values?.toDomain?.name,
              oldColor: (
                <ColorTag
                  color={
                    Number(previousDomainMetadata?.domainColor) ||
                    Color.LightPink
                  }
                />
              ),
              domainColor: (
                <ColorTag color={Number(domainColor) || Color.LightPink} />
              ),
              // Fallback to current name/description when there is no previous metadata obj
              oldDescription:
                previousDomainMetadata?.domainPurpose || domainPurpose,
              oldName: previousDomainMetadata?.domainName || domainName,
              domainPurpose,
              domainName,
              eventName,
              /*
               * Usefull if a event isn't found or doesn't have a message descriptor
               */
              eventNameDecorated: <b>{eventName}</b>,
              role: formattedRole,
              clientOrExtensionType: (
                <span className={styles.highlight}>{emmitedBy}</span>
              ),
            }}
          />
        </div>
        <div className={styles.details}>
          <div className={styles.roles}>
            {eventName &&
              EVENT_ROLES_MAP[eventName] &&
              EVENT_ROLES_MAP[eventName].map((role, index) => (
                <PermissionsLabel
                  key={autogeneratedIds[eventName][index]}
                  appearance={{ theme: 'simple' }}
                  permission={role}
                  minimal
                  infoMessage={MSG.rolesTooltip}
                  infoMessageValues={{
                    role,
                    icon: (
                      <div className={styles.tooltipIcon}>
                        <PermissionsLabel
                          permission={role}
                          appearance={{ theme: 'white' }}
                        />
                      </div>
                    ),
                  }}
                />
              ))}
          </div>
          {transactionHash && (
            <div className={styles.meta}>
              <TransactionMeta
                transactionHash={transactionHash}
                createdAt={createdAt}
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

ActionsPageEvent.displayName = displayName;

export default ActionsPageEvent;
