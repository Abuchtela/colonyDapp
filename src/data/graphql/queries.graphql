# import './fragments.graphql'

query Task($id: String!) {
  task(id: $id) {
    id
    ...Payouts
    assignedWorker {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
    assignedWorkerAddress
    cancelledAt
    colony {
      id
      colonyAddress
      colonyName
      avatarHash
      displayName
      nativeTokenAddress
    }
    colonyAddress
    commentCount @client
    createdAt
    creator {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
    creatorAddress
    description
    dueDate
    ethDomainId
    ethSkillId
    ethPotId
    events {
      id
      type
    }
    finalizedAt
    title
    workInvites {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
    workInviteAddresses
    workRequests {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
    workRequestAddresses
    txHash
  }
}

query TaskToEdit($id: String!) {
  task(id: $id) {
    id
    ...Payouts
    assignedWorker {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
    workRequests {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
    colony {
      id
      nativeTokenAddress
      subscribedUsers {
        id
        profile {
          displayName
          walletAddress
          username
          avatarHash
        }
      }
      tokenAddresses
      tokens @client {
        id
        address
        decimals
        name
        symbol
      }
    }
  }
}

query TaskFeedEvents($id: String!) {
  task(id: $id) {
    id
    colonyAddress
    events {
      ...TaskEvent
    }
    ethDomainId
    ethPotId
    finalizedAt
    txHash
    finalizedPayment @client {
      amount
      tokenAddress
      workerAddress
      transactionHash
    }
    ...Payouts
  }
}

query LoggedInUser {
  loggedInUser @client {
    walletAddress
    balance
    username
    ethereal
    networkId
  }
}

query User($address: String!) {
  user(address: $address) {
    id
    profile {
      username
      walletAddress
      displayName
      bio
      location
      website
      avatarHash
    }
  }
}

# This isn't currently being used anywhere, but... here it is anyways.
# In most cases, we'll want to fetch the reputation *after* the user is already fetched,
# as fetching reputation takes quite a bit longer.
query UserWithReputation($address: String!, $colonyAddress: String!, $domainId: Int) {
  user(address: $address) {
    id
    profile {
      username
      walletAddress
      displayName
      bio
      location
      website
      avatarHash
    }
    reputation(colonyAddress: $colonyAddress, domainId: $domainId) @client
  }
}

query UserReputation($address: String!, $colonyAddress: String!, $domainId: Int) {
  userReputation(address: $address, colonyAddress: $colonyAddress, domainId: $domainId) @client
}

query UserTasks($address: String!) {
  user(address: $address) {
    id
    tasks {
      id
      ...Payouts
      assignedWorker {
        id
        profile {
          avatarHash
        }
      }
      assignedWorkerAddress
      cancelledAt
      colony {
        id
        colonyName
        displayName
        nativeTokenAddress
      }
      colonyAddress
      commentCount @client
      createdAt
      creatorAddress
      dueDate
      ethDomainId
      ethSkillId
      events {
        id
        type
      }
      finalizedAt
      title
      workRequestAddresses
      txHash
    }
  }
}

query UserTokens($address: String!) {
  user(address: $address) {
    id
    tokenAddresses
    tokens @client {
      id
      address
      iconHash
      decimals
      name
      symbol
      balance(walletAddress: $address)
    }
  }
}

query Username($address: String!) {
  username(address: $address) @client
}

query UserAddress($name: String!) {
  userAddress(name: $name) @client
}

query ColonyFromName($name: String!, $address: String!) {
  colonyAddress(name: $name) @client @export(as: "address")
  colony(address: $address) {
    ...FullColony
  }
}

query ColonyName($address: String!) {
  colonyName(address: $address) @client
}

query ColonyAddress($name: String!) {
  colonyAddress(name: $name) @client
}

query Colony($address: String!) {
  colony(address: $address) {
    ...FullColony
  }
}

query ColonyTokens($address: String!) {
  colony(address: $address) {
    id
    ...Tokens
  }
}

query ColonyNativeToken($address: String!) {
  colony(address: $address) {
    id
    nativeTokenAddress
  }
}

query ColonyRoles($address: String!) {
  colony(address: $address) {
    id
    colonyAddress
    roles @client {
      address
      domains {
        domainId
        roles
      }
    }
  }
}

query ColonyTransfers($address: String!) {
  colony(address: $address) {
    id
    colonyAddress
    transfers @client {
      amount
      hash
      colonyAddress
      date
      from
      hash
      incoming
      to
      token
    }
    unclaimedTransfers @client {
      amount
      hash
      colonyAddress
      date
      from
      hash
      incoming
      to
      token
    }
  }
}

query ColonyEvents($address: String!) {
  colony(address: $address) {
    id
    colonyAddress
    events @client {
      ...FullNetworkEvent
    }
  }
}

query TokenBalancesForDomains($colonyAddress: String!, $tokenAddresses: [String!]!, $domainIds: [Int!]) {
  tokens(addresses: $tokenAddresses) @client {
    id
    address
    iconHash
    decimals
    name
    symbol
    balances(colonyAddress: $colonyAddress, domainIds: $domainIds) {
      domainId
      amount
    }
  }
}

query ColonyProfile($address: String!) {
  colony(address: $address) {
    ...ColonyProfile
  }
}

query UserColonies($address: String!) {
  user(address: $address) {
    id
    colonies {
      id
      avatarHash
      colonyAddress
      colonyName
      displayName
    }
    colonyAddresses
  }
}

query UserColonyAddresses($address: String!) {
  user(address: $address) {
    id
    colonyAddresses
  }
}

query ColonyTasks($address: String!) {
  colony(address: $address) {
    id
    tasks {
      id
      ...Payouts
      assignedWorker {
        id
        profile {
          avatarHash
        }
      }
      assignedWorkerAddress
      cancelledAt
      colony {
        id
        colonyName
        displayName
        nativeTokenAddress
      }
      colonyAddress
      commentCount @client
      createdAt
      creatorAddress
      dueDate
      ethDomainId
      ethSkillId
      events {
        id
        type
      }
      finalizedAt
      title
      workRequestAddresses
      txHash
    }
  }
}

query ColonySubscribedUsers($colonyAddress: String!) {
  colony(address: $colonyAddress) {
    id
    subscribedUsers {
      id
      profile {
        avatarHash
        displayName
        username
        walletAddress
      }
    }
  }
}

query ColonyMembersWithReputation($colonyAddress: String!, $domainId: Int) {
  colonyMembersWithReputation(colonyAddress: $colonyAddress, domainId: $domainId) @client
}

query Domain($colonyAddress: String!, $ethDomainId: Int!) {
  domain(colonyAddress: $colonyAddress, ethDomainId: $ethDomainId) {
    id
    ethDomainId
    name
    ethParentDomainId
  }
}

query Token($address: String!) {
  token(address: $address) @client {
    id
    address
    iconHash
    decimals
    name
    symbol
  }
}

query TokenInfo($address: String!) {
  tokenInfo(address: $address) {
    decimals
    name
    symbol
    iconHash
  }
}

query ColonyDomains($colonyAddress: String!) {
  colony(address: $colonyAddress) {
    id
    domains {
      ...DomainFields
    }
  }
}

query UserNotifications($address: String!) {
  user(address: $address) {
    id
    notifications {
      id
      event {
        id
        type
        createdAt
        initiatorAddress
        sourceId
        sourceType
        ...EventContext
      }
      read
    }
  }
}

query SystemInfo {
  systemInfo {
    version
  }
}

query NetworkContracts {
  networkContracts @client {
    version
    feeInverse
  }
}

query ColonyAction($transactionHash: String!, $colonyAddress: String!) {
  colonyAction(transactionHash: $transactionHash, colonyAddress: $colonyAddress) @client {
    hash
    actionInitiator
    fromDomain
    toDomain
    recipient
    status
    events {
      name
      values
      createdAt
      emmitedBy
    }
    createdAt
    actionType
    amount
    tokenAddress
    annotationHash
  }
}

query TransactionMessages($transactionHash: String!) {
  transactionMessages(transactionHash: $transactionHash) {
    transactionHash
    messages {
    	...TransactionMessage
    }
  }
}

query TransactionMessagesCount($colonyAddress: String!) {
  transactionMessagesCount(colonyAddress: $colonyAddress) {
    colonyTransactionMessages {
      transactionHash
      count
    }
  }
}

# The Graph
#
# @NOTE All queries meant for the subgraph should be prepended with `Subgraph`
# otherwise they will be sent to our own graphql server
# Prepending them with `Subgraph` allows the client to decide what endpoint to use

query SubgraphActions($skip: Int!, $first: Int!, $colonyAddress: String!) {
  # @TODO Pagination
  # See the schema for the correct filters we need to pass in for pagination
  oneTxPayments(skip: $skip, first: $first, where: { payment_contains: $colonyAddress }) {
    id
    agent
    transaction {
      hash: id
      block {
        id
        timestamp
      }
    }
    payment {
      to
      domain {
        ethDomainId: domainChainId
        name
      }
      fundingPot {
        fundingPotPayouts {
          id
          token {
            address: id
            symbol
            decimals
          }
          amount
        }
      }
    }
  }
  events(where: { associatedColony_contains: $colonyAddress, name_in: ["TokensMinted(address,address,uint256)"] }) {
    id
    transaction {
      hash: id
      block {
        timestamp
      }
    }
    associatedColony {
      token {
        decimals
        symbol
      }
    }
    args
    address # Address of the contract that emitted the event
    name
  }
}

query SubgraphDomains($colonyAddress: String!) {
  domains(where: { colonyAddress: $colonyAddress }) {
    id
    domainChainId
    parent {
      id
      domainChainId
    }
    name
    colonyAddress
    metadata
    metadataHistory {
      id
      metadata
    }
  }
}
